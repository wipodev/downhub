This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
api/gui.py
api/main.py
build.py
extension/background.js
extension/content.js
extension/manifest.json
extension/toast.css
run_all.py
setup_api.py
setup_installer.iss
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="api/gui.py">
import tkinter as tk
from tkinter import scrolledtext, Menu
import requests
import os
import threading
import time

API_BASE = "http://127.0.0.1:8000"

def check_status(task_id):
    """Consulta peri√≥dicamente el estado del task."""
    while True:
        try:
            res = requests.get(f"{API_BASE}/status/{task_id}", timeout=5)
            if res.ok:
                data = res.json()
                status = data.get("status")
                if status == "completed":
                    log(f"‚úÖ Download completed: {data.get('file')}")
                    break
                elif status == "error":
                    log(f"‚ùå Error: {data.get('error_msg')}")
                    break
            else:
                log(f"‚ùå Status check failed: {res.status_code} - {res.text}")
                break
            time.sleep(2)
        except Exception as e:
            log(f"‚ùå Error checking status: {e}")
            break

def download_video():
    url = url_entry.get().strip()
    if not url:
        log("Please enter a video URL.")
        return
    try:
        log(f"Starting download: {url}")
        res = requests.post(f"{API_BASE}/download", json={"url": url}, timeout=5)
        if res.ok:
            data = res.json()
            task_id = data.get("task_id")
            log(f"‚ÑπÔ∏è Download started (Task ID: {task_id})")
            url_entry.delete(0, tk.END)
            if task_id:
                threading.Thread(target=check_status, args=(task_id,), daemon=True).start()
        else:
            log(f"‚ùå Error: {res.status_code} - {res.text}")
    except Exception as e:
        log(f"‚ùå Error: {e}")

def log(message):
    log_area.config(state=tk.NORMAL)
    log_area.insert(tk.END, message + "\n")
    log_area.see(tk.END)
    log_area.config(state=tk.DISABLED)

def paste_from_clipboard(event=None):
    try:
        url_entry.delete(0, tk.END)
        url_entry.insert(tk.END, root.clipboard_get())
    except tk.TclError:
        pass

def show_context_menu(event):
    context_menu.post(event.x_root, event.y_root)

# --- UI Setup ---
root = tk.Tk()
root.title("DownHub GUI")
root.geometry("500x300")
root.resizable(False, False)

# Set icon
icon_path = os.path.join(os.path.dirname(__file__), "..", "assets", "icon2.ico")
if os.path.exists(icon_path):
    root.iconbitmap(icon_path)

main_frame = tk.Frame(root)
main_frame.pack(fill="both", expand=True, pady=5)

# Label + Entry
tk.Label(main_frame, text="Video URL:", font=("Segoe UI", 10, "bold")).pack(pady=5)

url_entry = tk.Entry(main_frame, width=60)
url_entry.pack(pady=5)
url_entry.focus()

# Context menu for paste
context_menu = Menu(root, tearoff=0)
context_menu.add_command(label="Paste", command=paste_from_clipboard)
url_entry.bind("<Button-3>", show_context_menu)

# Download button
download_btn = tk.Button(main_frame, text="Download", width=15, command=download_video)
download_btn.pack(pady=5)

# Log area + footer juntos
log_frame = tk.Frame(main_frame)
log_frame.pack(fill="both", expand=True, pady=(10, 0))

log_area = scrolledtext.ScrolledText(
    log_frame, wrap=tk.WORD, width=60, height=10, state=tk.DISABLED
)
log_area.pack(side="top", fill="both", expand=True)

footer_text = "Ensure DownHubService is running before using this GUI."
tk.Label(
    log_frame,
    text=footer_text,
    font=("Segoe UI", 8),
    wraplength=460,
    justify="center"
).pack(side="bottom", pady=(2, 5))

root.mainloop()
</file>

<file path="extension/toast.css">
#dl-notification-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 999999;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

#dl-notification-container .dl-toast {
  padding: 10px 14px;
  border-radius: 6px;
  color: #fff;
  font-size: 14px;
  font-family: sans-serif;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
  opacity: 0;
  transform: translateY(-10px);
  animation: toastSlideIn 0.3s ease forwards;
}

#dl-notification-container .dl-toast.success {
  background: rgba(0, 150, 0, 0.85);
}

#dl-notification-container .dl-toast.error {
  background: rgba(200, 0, 0, 0.85);
}

#dl-notification-container .dl-toast.info {
  background: rgba(0, 0, 0, 0.75);
}

@keyframes toastSlideIn {
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes toastSlideOut {
  to {
    opacity: 0;
    transform: translateY(-10px);
  }
}
</file>

<file path="run_all.py">
import subprocess
import sys
import os
import time

api_path = os.path.join("api", "main.py")
api_process = subprocess.Popen([sys.executable, api_path])
time.sleep(2)

try:
    import api.gui
except Exception as e:
    print(f"Error ejecutando la GUI: {e}")
finally:
    api_process.terminate()
</file>

<file path="build.py">
import subprocess
import os

def run_command(command):
    """Execute a command on the system"""
    try:
        subprocess.check_call(command, shell=True)
    except subprocess.CalledProcessError as e:
        print(f"Error executing command: {e}")
        exit(1)

def main():
    local_appdata = os.environ["LOCALAPPDATA"]

    print("Compiling API...")
    run_command("python setup_api.py build")
    
    print("Packaging extension...")
    run_command("python setup_ext.py")
    
    print("Creating installer...")
    inno_path = os.path.join(local_appdata, r"Programs\Inno Setup 6\ISCC.exe")
    run_command(f'"{inno_path}" setup_installer.iss')
    
    print("Construction process completed.")

if __name__ == "__main__":
    main()
</file>

<file path="extension/background.js">
// background.js

// Relay requests to the local API (FastAPI) to avoid CORS surprises and keep logic centralized.
chrome.runtime.onMessage.addListener(async (msg, _sender, sendResponse) => {
  if (msg?.type === "DOWNLOAD_URL" && typeof msg.url === "string") {
    try {
      const res = await fetch("http://127.0.0.1:8000/download", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ url: msg.url }),
      });

      let data = null;
      try {
        data = await res.json();
      } catch {
        data = { message: "No JSON body" };
      }

      sendResponse({ ok: res.ok, status: res.status, data });
    } catch (err) {
      sendResponse({ ok: false, status: 0, error: String(err) });
    }
    // Keep the message channel open for the async response
    return true;
  }
});
</file>

<file path="extension/content.js">
// content.js

// --- Config -----------------------------------------------------------------
const API_MESSAGE = "DOWNLOAD_URL";

// Selectors you provided
const YT_CONTAINER_SELECTOR =
  "#movie_player > div.ytp-chrome-bottom > div.ytp-chrome-controls > div.ytp-right-controls";

const KICK_CONTAINER_SELECTOR = "#injected-embedded-channel-player-video > div > div > div:nth-child(2)";

// Unique IDs to avoid double injections
const BTN_ID_YT = "dl-icon-btn-yt";
const BTN_ID_KICK = "dl-icon-btn-kick";

// --- Notification container setup -------------------------------------------
let notificationContainer = document.getElementById("dl-notification-container");
if (!notificationContainer) {
  notificationContainer = document.createElement("div");
  notificationContainer.id = "dl-notification-container";
  document.body.appendChild(notificationContainer);
}

function showNotification(message, type, duration = 2000) {
  const notification = document.createElement("div");
  notification.className = `dl-toast ${type}`;
  notification.textContent = message;

  notificationContainer.appendChild(notification);

  setTimeout(() => {
    notification.style.animation = "toastSlideOut 0.3s ease forwards";
    setTimeout(() => {
      if (notification.parentNode) {
        notificationContainer.removeChild(notification);
      }
    }, 300);
  }, duration);
}

// --- Site detection ----------------------------------------------------------
function isYouTubeWatch() {
  return location.hostname.includes("youtube.com") && /\/watch/.test(location.pathname);
}

function isKickVod() {
  return location.hostname.includes("kick.com") && /^\/[^/]+\/videos?\//.test(location.pathname);
}

// --- Utilities ---------------------------------------------------------------
function debounce(fn, ms = 100) {
  let t;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), ms);
  };
}

function sendToBackend(url) {
  return new Promise((resolve) => {
    chrome.runtime.sendMessage({ type: API_MESSAGE, url }, (res) => resolve(res));
  });
}

function createIconButton({ id, title = "Download" }) {
  const btn = document.createElement("button");
  btn.id = id;
  btn.title = title;
  btn.classList.add("ytp-button");

  if (title === "Download VOD") {
    Object.assign(btn.style, {
      padding: "5px",
      width: "44px",
      height: "44px",
      cursor: "pointer",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      opacity: "0.95",
    });
  }

  btn.addEventListener("mouseenter", () => (btn.style.opacity = "1"));
  btn.addEventListener("mouseleave", () => (btn.style.opacity = "0.95"));

  btn.innerHTML = `
    <svg version="1.1" width="100%" height="100%" viewBox="0 0 36 36">
 <path d="m9.2 20.447c-0.6648 0-1.2 0.54774-1.2 1.2281v5.5437c0 0.0048 6.52e-4 0.0094 7.04e-4 0.01422-4e-5 0.0047-7.04e-4 0.0092-7.04e-4 0.0139 0 0.6648 0.5352 1.2 1.2 1.2h17.6c0.6648 0 1.2-0.5352 1.2-1.2 0-0.0047-6.48e-4 -0.0092-7.04e-4 -0.0139 4e-5 -0.0048 7.04e-4 -0.0094 7.04e-4 -0.01422v-5.5437c0-0.68039-0.5352-1.2281-1.2-1.2281s-1.2 0.54774-1.2 1.2281v4.3719h-15.2v-4.3719c0-0.68039-0.5352-1.2281-1.2-1.2281zm8.7989-12.895c-0.6648 0-1.2 0.5352-1.2 1.2v10.701l-3.3244-3.3244c-0.47008-0.47008-1.2269-0.47008-1.697 0-0.47008 0.47009-0.47008 1.2269 0 1.697l5.3346 5.3346c0.17055 0.18717 0.399 0.32012 0.65844 0.36976 0.0026 4.8e-4 0.0052 6.8e-4 0.0077 0.0012 0.03437 0.0063 0.06903 0.01178 0.10438 0.01516 0.03184 0.0031 0.06375 0.0043 0.0957 0.0048 0.0069 0 0.01361 1e-3 0.02055 1e-3h5.44e-4c0.03976 1.6e-5 0.07954-0.0021 0.11914-6e-3 0.01766-0.0017 0.03477-0.0051 0.05219-0.0076 0.02077-3e-3 0.04157-0.0054 0.06219-0.0095 0.02671-0.0052 0.05272-0.01224 0.07875-0.01922 0.01096-3e-3 0.02207-0.0052 0.03297-0.0084 0.03293-0.0098 0.06498-0.02148 0.09664-0.03398 0.0037-0.0015 0.0075-0.0026 0.01117-0.0041 0.15661-0.06367 0.29616-0.15942 0.41133-0.27914l5.3588-5.3587c0.47008-0.47008 0.47008-1.2269 0-1.697-0.47009-0.47008-1.227-0.47008-1.6971 0l-3.3266 3.3266v-10.703c0-0.6648-0.5352-1.2-1.2-1.2z" fill="#fff"/>
</svg>
  `;

  btn.addEventListener("click", async () => {
    const prev = btn.innerHTML;
    btn.disabled = true;

    showNotification("Starting download...", "info", 3000);

    try {
      const res = await sendToBackend(location.href);

      if (res?.ok && res?.data?.task_id) {
        const taskId = res.data.task_id;
        btn.style.filter = "drop-shadow(0 0 6px rgba(0,255,0,.6))";
        showNotification("Download started in background", "success", 3000);

        // üîÑ Polling
        const interval = setInterval(async () => {
          try {
            const statusRes = await fetch(`http://127.0.0.1:8000/status/${taskId}`);
            const statusData = await statusRes.json();

            if (statusData.status === "completed") {
              showNotification("‚úÖ Download completed!", "success", 4000);
              clearInterval(interval);
            } else if (statusData.status === "error") {
              showNotification(`‚ùå Error: ${statusData.error_msg}`, "error", 4000);
              clearInterval(interval);
            }
          } catch (err) {
            console.error("Status check error:", err);
            clearInterval(interval);
          }
        }, 4000);
      } else {
        btn.style.filter = "drop-shadow(0 0 6px rgba(255,0,0,.6))";
        showNotification("Download failed!", "error", 4000);
      }

      setTimeout(() => (btn.style.filter = ""), 800);
    } catch (e) {
      console.error(e);
      showNotification("An error occurred!", "error", 4000);
    } finally {
      btn.innerHTML = prev;
      btn.disabled = false;
    }
  });

  return btn;
}

function alreadyInjected(container, id) {
  return container && container.querySelector(`#${id}`);
}

function waitForElement(selector, timeoutMs = 20000) {
  return new Promise((resolve, reject) => {
    const existing = document.querySelector(selector);
    if (existing) {
      return resolve(existing);
    }

    const obs = new MutationObserver(() => {
      const el = document.querySelector(selector);
      if (el) {
        obs.disconnect();
        resolve(el);
      }
    });
    obs.observe(document.documentElement, { childList: true, subtree: true });

    setTimeout(() => {
      obs.disconnect();
      const el = document.querySelector(selector);
      if (el) {
        resolve(el);
      } else {
        reject(new Error("Timeout waiting for: " + selector));
      }
    }, timeoutMs);
  });
}

// --- Injection per site ------------------------------------------------------
async function injectYouTube() {
  if (!isYouTubeWatch()) return;
  try {
    const container = await waitForElement(YT_CONTAINER_SELECTOR, 25000);
    if (!container || alreadyInjected(container, BTN_ID_YT)) return;
    const btn = createIconButton({ id: BTN_ID_YT, title: "Download" });
    container.insertBefore(btn, container.firstChild);
  } catch {}
}

async function injectKick() {
  if (!isKickVod()) return;
  try {
    const container = await waitForElement(KICK_CONTAINER_SELECTOR, 25000);
    if (!container || alreadyInjected(container, BTN_ID_KICK)) {
      return;
    }
    const btn = createIconButton({ id: BTN_ID_KICK, title: "Download VOD" });
    container.appendChild(btn);
  } catch (err) {
    console.error("[Downloader] injectKick() error:", err);
  }
}

// --- Router (SPA) handling ---------------------------------------------------
let lastUrl = location.href;

const handleRouteChange = debounce(() => {
  if (lastUrl !== location.href) {
    lastUrl = location.href;
    injectYouTube();
    injectKick();
  }
}, 80);

const origPushState = history.pushState;
history.pushState = function () {
  origPushState.apply(this, arguments);
  handleRouteChange();
};

const origReplaceState = history.replaceState;
history.replaceState = function () {
  origReplaceState.apply(this, arguments);
  handleRouteChange();
};

window.addEventListener("popstate", handleRouteChange);

const mo = new MutationObserver(
  debounce(() => {
    injectYouTube();
    injectKick();
  }, 150)
);
mo.observe(document.documentElement, { childList: true, subtree: true });

// Initial run
injectYouTube();
injectKick();
</file>

<file path="extension/manifest.json">
{
  "manifest_version": 3,
  "name": "DownTube",
  "version": "0.0.3",
  "description": "Extension to download YouTube videos using a local backend.",
  "permissions": ["scripting", "activeTab"],
  "host_permissions": [
    "https://www.youtube.com/*",
    "https://youtube.com/*",
    "https://m.youtube.com/*",
    "https://www.kick.com/*",
    "https://kick.com/*",
    "http://127.0.0.1:8000/*",
    "http://localhost:8000/*"
  ],
  "icons": {
    "16": "icons/icon-16x16.png",
    "48": "icons/icon-48x48.png",
    "128": "icons/icon-128x128.png"
  },
  "background": {
    "service_worker": "background.js"
  },
  "content_scripts": [
    {
      "matches": [
        "https://www.youtube.com/*",
        "https://youtube.com/*",
        "https://m.youtube.com/*",
        "https://www.kick.com/*",
        "https://kick.com/*"
      ],
      "js": ["content.js"],
      "css": ["toast.css"],
      "run_at": "document_idle"
    }
  ]
}
</file>

<file path="setup_api.py">
from cx_Freeze import setup, Executable

build_options = {
    "packages": ["os", "sys", "fastapi", "yt_dlp", "uvicorn", "tkinter", "requests"],
    "excludes": [],
    "include_files": [
        ("api/bin/ffmpeg.exe", "bin/ffmpeg.exe"),
        ("api/bin/ffprobe.exe", "bin/ffprobe.exe"),
    ],
}

executables = [
    Executable(
        script="api/main.py",
        target_name="DownHubService.exe",
        icon="assets/icon.ico",
        base="win32gui",
    ),
    Executable(
        script="api/gui.py",
        target_name="DownHubGUI.exe",
        icon="assets/icon.ico",
        base="win32gui",
    )
]

setup(
    name="DownHubTools",
    version="0.0.3",
    description="YouTube/Kick video download service + GUI",
    options={"build_exe": build_options},
    executables=executables,
)
</file>

<file path="api/main.py">
# python modules
import os
import sys
import logging
import time
import traceback
import threading
import uuid

# third-party modules
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from yt_dlp import YoutubeDL
from uvicorn import Config, Server

# --- Logging config ---
log_file = os.path.join(os.path.expanduser("~"), "DownHubService.log")
logging.basicConfig(
    filename=log_file,
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
)

sys.stdout = open(log_file, "a")
sys.stderr = open(log_file, "a")

logging.info("Starting DownHubService...")

current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.append(current_dir)

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "chrome-extension://mppaemmnjblpfpiijkbmgfbkmkgjlean",
        "http://127.0.0.1",
        "http://localhost"
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class VideoRequest(BaseModel):
    url: str

tasks = {}  # {task_id: {"status": "pending"|"completed"|"error", "file": str|None, "error_msg": str|None}}

def download_job(task_id, url):
    downloads_folder = os.path.join(os.path.expanduser("~"), "Downloads")
    base_dir = os.path.dirname(
        os.path.abspath(sys.executable if getattr(sys, 'frozen', False) else __file__)
    )

    ydl_opts = {
        'outtmpl': os.path.join(downloads_folder, '%(title)s.%(ext)s'),
        "restrictfilenames": True,
        'format': 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',
        "merge_output_format": "mp4",
        "hls_prefer_native": True,
        "continuedl": True,
        "fragment_retries": 10,
        "retries": 5,
        "concurrent_fragment_downloads": 5,
        "quiet": True,
        "noprogress": True,
        "no_mtime": True,
        "http_headers": {
            "User-Agent": (
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                "AppleWebKit/537.36 (KHTML, like Gecko) "
                "Chrome/120.0.0.0 Safari/537.36"
            )
        },
        'ffmpeg_location': os.path.join(base_dir, 'bin'),
    }

    try:
        with YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=True)
            file_path = os.path.join(downloads_folder, f"{info['title']}.{info['ext']}")

        tasks[task_id]["status"] = "completed"
        tasks[task_id]["file"] = file_path
        logging.info(f"Download completed for task {task_id}")
    except Exception as e:
        tasks[task_id]["status"] = "error"
        tasks[task_id]["error_msg"] = str(e)
        logging.error(f"Error in task {task_id}: {e}")
        logging.error(traceback.format_exc())

@app.post("/download")
def start_download(request: VideoRequest):
    task_id = str(uuid.uuid4())
    tasks[task_id] = {"status": "pending", "file": None, "error_msg": None}

    threading.Thread(target=download_job, args=(task_id, request.url), daemon=True).start()

    logging.info(f"Download started for {request.url} as task {task_id}")
    return {"message": "Download started in background", "task_id": task_id}

@app.get("/status/{task_id}")
def get_status(task_id: str):
    task = tasks.get(task_id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    return task

if __name__ == "__main__":
    logger = logging.getLogger("uvicorn")
    handler = logging.StreamHandler()
    formatter = logging.Formatter("%(levelname)s: %(message)s")
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(logging.INFO)

    config = Config(app=app, host="127.0.0.1", port=8000, log_level="info", use_colors=False)
    server = Server(config)

    logging.info("Starting server...")
    server.run()
</file>

<file path="setup_installer.iss">
[Setup]
AppName=DownHubService
AppVersion=0.0.3
DefaultDirName={autopf}\DownHubService
DefaultGroupName=DownHubService
OutputDir=Output
OutputBaseFilename=DownHubServiceInstaller
Compression=lzma
SolidCompression=yes
UninstallDisplayIcon={app}\icon.ico

[Languages]
Name: "en"; MessagesFile: "compiler:Default.isl"
Name: "es"; MessagesFile: "compiler:Languages\Spanish.isl"

[Files]
; Copia todos los archivos de la compilaci√≥n cx_Freeze
Source: "build\exe.win-amd64-3.11\*"; DestDir: "{app}"; Flags: onlyifdoesntexist recursesubdirs createallsubdirs
; API
Source: "build\exe.win-amd64-3.11\DownHubService.exe"; DestDir: "{app}"; Flags: ignoreversion
; GUI
Source: "build\exe.win-amd64-3.11\DownHubGUI.exe"; DestDir: "{app}"; Flags: ignoreversion
Source: "extension\*"; DestDir: "{app}\extension"; Flags: comparetimestamp recursesubdirs createallsubdirs
Source: "README.md"; DestDir: "{app}"; Flags: ignoreversion; AfterInstall: extensionInstall
Source: "assets\icon.ico"; DestDir: "{app}"; Flags: onlyifdestfileexists

[Icons]
; Servicio API en carpeta de inicio
Name: "{commonstartup}\DownHubService"; Filename: "{app}\DownHubService.exe"; WorkingDir: "{app}"
; GUI en escritorio
Name: "{commondesktop}\DownHubGUI"; Filename: "{app}\DownHubGUI.exe"; WorkingDir: "{app}"; IconFilename: "{app}\icon.ico"

[Run]
Filename: "{app}\DownHubService.exe"; Description: "Run DownHubService"; Flags: nowait postinstall skipifsilent

[Code]
procedure extensionInstall();
begin
  MsgBox('Para instalar la extensi√≥n en Google Chrome:' + #13#10 +
         '1. Abra Google Chrome.' + #13#10 +
         '2. Escriba "chrome://extensions" en la barra de direcciones y presione Enter.' + #13#10 +
         '3. Active el modo desarrollador.' + #13#10 +
         '4. Haz clic en "Cargar extension sin empaquetar".' + #13#10 +
         '5. Selecciona la carpeta de la extensi√≥n en "' + ExpandConstant('{app}') + '\extension" y haz clic en "Cargar".',
         mbInformation, MB_OK);
end;
</file>

</files>
